                                       编译器的构建流程
编译器编写的三个步骤：

1、词法分析器：用于将字符串转化成内部的表示结构

2、语法分析器：将词法分析得到的标记流（token）生成一颗语法树

3、目标代码的生成：将语法树转化成目标代码

自己实现的过程：

1、构建自己的虚拟机以及指令集，之后生成的目标代码便是我们的指令集

2、构建我们的词法分析器

3、构建语法分析器

编译器的框架
编译器主要包括4个函数：

1、next()用于词法分析，获取下一个标记，它将自动忽略空白字符

2、program()语法分析的入口，分析整个C语言程序

3、expression(level)用于解析一个表达式

4、eval()虚拟机的入口，用于解释目标代码

因为表达式在语法分析中相对独立并且比较复杂，所以我将它单独作为一个函数。

实现一个简单的编译器，什么都不做。

main()函数就是读取一个源代码文件，逐个读取每个字符，并输出每个字符。然后调用以上四个函数。见代码comp1.c

                                                  虚拟机
构建一台虚拟的电脑，设定自己的指令集，运行自己的指令集，即自己实现一套汇编语言。组为我们的编译器最终输出的目标代码。

计算机的内部工作原理：

计算机的三个基本部件：CPU、寄存器以及内存。代码（汇编指令）以二进制的形式保存在内存中，CPU从中一条条地加载指令执行。程序运行的状态保存在寄存器中。

内存

现代的操作系统都不直接使用内存，而是使用虚拟内存。虚拟内存可以理解为一种映射，在程序看来，我们可以使用全部的内存地址，而操作系统需要将他们映射到实际的内存上。进程的内存一般会被分成以下几个段：

1、代码段（text）：用以保存代码（指令）

2、数据段（data）：用以存放初始化了的数据，如int i = 10; ，就需要保存在数据段中。

3、未初始化数据段（bss）：用以存放未初始化的数据，如int i[1000]; ，因为不关心其中真正的数值，所以单独存放可以节省空间，减少程序的体积。

4、栈（stack）：用以处理函数调用相关的数据，如调用帧或者函数的局部变量等。

5、堆（heap）：用于程序动态分配内存。

但是我们的虚拟机并不模拟完整的计算机，我们只关心三个内容：代码段、数据段以及栈。其中数据段我们只存放字符串，因为我们的编译器并不支持初始化变量，因此我们也不需要未初始化数据段。理论上我们的虚拟器需要维护自己的堆用以内存分配，但实际实现上较为复杂且与编译无关，所以我们引入一个指令MSET，使我们能直接使用编译器（解释器）中的内存。

我们会在代码段（text）中存放如指针/内存地址的数据，他们全是无符号的；数据段（data）只存放字符串，是char* 类型的。


寄存器

计算机中的寄存器用以存放计算机的运行状态，真正的计算机中有许多不同种类的寄存器，但我们的虚拟机中只使用了4个寄存器，分别如下：

1、PC程序计数器：存放的是一个内存地址，该地址中存放着下一条要执行的计算机指令。

2、SP指针寄存器：永远指向当前的栈顶。注意的是由于栈是位于高地址并向低地址增长的，所以入栈时SP的值减小。

3、BP基址指针：用于指向栈的某些位置，在调用函数时会使用到它。

4、AX通用寄存器：用于存放一条指令执行后的结果。

这些寄存器都只是用于保存计算机的某些状态的。

PC在初始时应指向目标代码中的main函数 

指令集

指令集是CPU能识别的命令的集合，也可以说是CPU能理解的语言。

首先在全局变量中加入一个枚举类型，存放我们要支持的全部指令。

// instructions

enum { LEA ,IMM ,JMP ,CALL,JZ  ,JNZ ,ENT ,ADJ ,LEV ,LI  ,LC  ,SI  ,SC  ,PUSH,
OR  ,XOR ,AND ,EQ  ,NE  ,LT  ,GT  ,LE  ,GE  ,SHL ,SHR ,ADD ,SUB ,MUL ,DIV ,MOD ,
OPEN,  READ,  CLOS,  PRTF,  MALC,  MSET,  MCMP,  EXIT };

这些指令中带参数的指令在前，没有参数的指令在后。

MOV

MOV是所有指令中最基础的一个，用于将数据放进寄存器或内存地址，有点类似于C语言中的赋值语句。X86中的MOV指令有两个参数，分别是源地址和目标地址：MOV dest, source，表示将source的内容放在dest中，它们可以是一个数，寄存器或是一个内存地址。

因为我们的虚拟机只有一个寄存器，并且识别这些参数的类型非常困难，所以我们将MOV指令拆分成5个指令，这些指令只接受一个参数，如下：

1、IMM <num>将<num>放入寄存器ax中

2、LC将对应地址中的字符载入ax中，要求ax中存放地址

3、LI将对应地址中的整数载入ax中，要求ax中存放地址

4、SC将ax中的数据作为字符存放入地址中，要求栈顶存放地址

5、SI将ax中的数据作为整数放入地址中，要求栈顶存放地址

在上述指令中，只有IMM需要有参数，且不需要判断类型，降低了难度。

*sp++的作用是退栈，相当于POP操作。


PUSH：将ax的值放入栈中。

JMP：跳转指令，无条件地将当前的PC寄存器设置为指定的<addr>

PC寄存器指向的是下一条指令，所以此时它存放的是JMP指令的参数，即<addr>的值。

JZ/JNZ：为了实现if语句，我们需要条件判断相关的指令。这里只实现了两个最简单的条件判断，即结果（ax）为零或不为零情况下的跳转


子函数调用：要引入的命令：CALL，ENT，ADJ，LEV

CALL <addr>：跳转到为<addr>的子函数，RET用于从子函数中返回，调用LEV实现。

在这里不能直接使用JMP指令，因为当我们从子函数中返回时，程序需要回到跳转之前的地方继续运行，这就需要事先将这个位置的信息存储起来。反过来，子函数要返回时，就需要获取并恢复这个信息，因此实际中我们将PC保存在栈中。

在实际调用函数时，不仅要考虑函数的地址，还要考虑如何传递参数和如何返回结果。这里我们规定，如果子函数有返回结果，那么就在返回会时保存在ax中，它可以是一个值，也可以是一个地址。

ENT指令：ENT <size>指的是enter，用于实现‘make new call frame’的功能，即保存当前的栈指针，同在栈上保留一定的空间，用以存放局部变量。

ADJ 指令：ADJ <size>:用于实现‘remove arguments from frame’。在将调用子函数时压入栈中的数据清除。

LEV指令：本质上这个指令并不是必须的，只是我们的指令集中没有pop指令。对应汇编指令为：

; restore old call frame

       mov     esp, ebp

pop     ebp

; return

ret

LEA指令：上面的一些指令解决了调用帧的问题，但还有一个问题就是如何在子函数中获得传入的参数。

运算符指令：

我们为C语言中支持的运算符都提供对应的汇编指令。每个运算符都是二元的，即有两个参数，第一个参数放在栈顶，第二个参数放在ax中。这个顺序要特别注意，因为像-，/之类的运算符是与参数顺序有关的，计算后将栈顶的参数退栈，结果存放在寄存器ax中。因此在计算结束后，两个参数都无法取得了。

内置函数：

程序要有用，除了核心的逻辑外还需要输入和输出，如C语言中我们经常使用printf函数就是用于输出。但是printf函数的实现很复杂，但这些函数与编译器没有太大联系，所以我们继续实现新的指令，从虚拟机的角度给予支持。


